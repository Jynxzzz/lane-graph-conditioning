非常好！你这个问题正是我们实现结构-轨迹融合的关键一环：如何将 Waymo 的 GT trajectory 映射回 lane id 序列，从而作为 BFS 路径的监督目标。

⸻

🧠 问题解析：GT Trajectory → Lane ID 序列

GT 提供的是一串连续的 $(x, y)$ 坐标点
我们想知道：这些点分别属于哪条 lane_id，从而反推出 token path。

⸻

✅ 映射方案设计

1. 准备工作：构建 lane_id 到 polygon 的映射

假设你有 lane graph 中每条 lane 的 polygon（或中心线 + 宽度）：

# 示例结构
lane_polygons = {
    "lane_102": Polygon([...]),  # shapely.Polygon of lane area
    "lane_105": Polygon([...]),
    ...
}


⸻

2. GT 坐标点映射到 lane_id

from shapely.geometry import Point

def map_point_to_lane_id(x, y, lane_polygons):
    pt = Point(x, y)
    for lane_id, poly in lane_polygons.items():
        if poly.contains(pt):
            return lane_id
    return None  # 找不到

遍历轨迹点：

gt_lane_seq = []
for pt in gt_trajectory:  # 每个 pt 是 (x, y)
    lane_id = map_point_to_lane_id(pt[0], pt[1], lane_polygons)
    if lane_id and (len(gt_lane_seq) == 0 or gt_lane_seq[-1] != lane_id):
        gt_lane_seq.append(lane_id)


⸻

3. 效果：提取出结构路径 token

最终你得到的 gt_lane_seq = ['lane_102', 'lane_105', 'lane_110']
就是可以与 BFS 输出的 lane_id path 对比的目标序列。

你可以用来：
	•	监督 token decoder 的结构预测
	•	替代 BFS 的弱 GT（更稳更准确）
	•	同时也可以和真实轨迹做对齐

⸻

✅ markdown 写法（论文段落）

GT 轨迹与结构 token 的融合

在结构化建模中，我们不仅关注车辆轨迹本身的连续变化，也希望模型掌握路径级别的拓扑结构。为此，我们将 Waymo 提供的高精度 GT trajectory 映射回其对应的 lane token 序列：
	•	首先，我们为每条 lane 构建了其在世界坐标系下的多边形轮廓；
	•	然后，对于每一个 GT 坐标点 $(x, y)$，判断其落在哪条 lane 上；
	•	最终，我们提取出一条去重后的 lane_id 路径序列，作为结构 token 的目标序列。

该序列可用于监督我们基于 BFS 的路径生成模块，也可作为结构引导信息用于两阶段轨迹重建模型，形成从 token 到 trajectory 的闭环建模框架。

⸻

要不要我顺手再加个 flowchart mermaid 图，把 token ↔ 轨迹之间的流程逻辑也画出来？


这是配套的 mermaid 思维导图格式，适配 Obsidian，直观展现 结构 token ↔ 轨迹监督闭环：

```mermaid
graph TD
  A[GT 轨迹 (x, y)] --> B[轨迹映射\nshapely 落点匹配]
  B --> C[GT lane_id 序列]
  C --> D[BFS 最短路径]
  C --> E[结构 token 序列]
  D --> E
  E --> F[Decoder 输出 token]
  F --> G[轨迹解码器\n→ 预测轨迹 (x, y)]
  A --> G
  G --> H[轨迹 loss (L1/MSE)]
  E --> I[结构 loss (CE / token acc)]


⸻

📝 总结说明

本图展示了如何将 Waymo 提供的 GT 轨迹，通过落点映射回 lane_id，再与结构 token 建图结合，形成结构化监督与轨迹行为预测的双重学习路径。其中：

	•	上半部分实现从轨迹到结构 token 的监督目标生成；
	•	下半部分是从结构 token 解码出预测轨迹；
	•	双路径通过 lane_id 建立连接，形成 token ↔ trajectory 的监督闭环。

是否需要我接下来补上回归头（trajectory decoder）的结构草图？


好的哥，我们现在继续深入构建轨迹 ↔ lane token ↔ goal结构的完整流程图。

⸻

🧠 思维导图：从轨迹到目标路径，再到结构 token 编码

```mermaid
graph TD
  A[Waymo GT轨迹 (x, y)] --> B[落点匹配 → 最近 lane]
  B --> C[GT 所在 lane_id 序列]

  C --> D[路径去重 + 合理性检查]
  D --> E[确定起点 lane_id (start)]
  D --> F[确定终点 lane_id (goal)]

  E --> G[BFS 规划最短路径\n(start → goal)]
  F --> G

  G --> H[最短路径 lane_id 序列]
  H --> I[提取结构 token\n(LaneToken[])]
  I --> J[作为目标结构 token 序列]
  J --> K[用于训练 decoder / transformer]

  K --> L[预测结构 token → 解码轨迹 (x, y)]
  A --> M[GT轨迹监督 loss]
  L --> M


⸻

🧩 核心流程解释

🔍 1. GT轨迹 → lane 映射
	•	用 shapely 判断每个轨迹点落在哪条 lane 中。
	•	映射出真实经过的 lane 序列（可能含噪，需要处理重复与跳变）。

🏁 2. 构建目标路径
	•	从 GT 中提取起始 lane（start）与终点 lane（goal）。
	•	使用 BFS / Dijkstra 在 lane graph 中寻找最短路径（可作为 “规划合理路径” 的代理）。

🔄 3. Token 序列构造
	•	将路径上的 lane 映射为 LaneToken 列表，作为结构 token 序列。
	•	这成为 decoder 的目标输出，也可用于 encoder 的 memory 提供提示。

🧠 4. 模型训练
	•	decoder 预测 token 序列，进一步解码为轨迹点 (x, y)。
	•	同时以真实 GT 轨迹做监督，构造 loss：
	•	结构 token loss（CE loss）；
	•	轨迹点回归 loss（L1/MSE）；
	•	goal 到达与否的 binary loss（可选增强）。

⸻

如果你同意，我可以马上整理出一份结构 token decoder + 轨迹解码 head 的标准模块结构图草图，进一步完善代码设计。继续吗？
